---
description: TTSim project architecture and conventions
alwaysApply: true
---

# TTSim Project Overview

Godot 4.6 tabletop simulator in GDScript. Read `docs/ARCHITECTURE.md` and `AGENTS.md` for full details.

## Architecture

- **State stack** – Root manages states (TITLE_SCREEN, LOBBY, PLAYING, PAUSED). Use `change_state()`, `push_state()`, `pop_state()`.
- **Autoloads** – Singletons for cross-cutting concerns: Constants, UIManager, LevelManager, AssetPackManager, NetworkManager, GameState, etc. Always use direct references (`X.method()`), never `has_node("/root/X")`.
- **Signals** – Prefer direct signal connections. **No EventBus** – use autoload services instead. Disconnect autoload signals in `_exit_tree()` for non-autoload nodes.
- **Host-authoritative** – GameState is authoritative; NetworkStateSync broadcasts to clients.

## Where to Add Things

| Feature | Location |
|---------|----------|
| New state | Root.State enum, `_enter_*_state()` / `_exit_*_state()` |
| New autoload | `autoloads/`, register in project.godot |
| UI component | `scenes/ui/`, extend AnimatedVisibilityContainer if animated |
| Level/token logic | LevelPlayController, BoardTokenFactory, GameState |
| Environment preset | `EnvironmentPresets.PRESETS` in `utils/environment_presets.gd` |
| Environment property | `PROPERTY_DEFAULTS`, `_apply_config_to_environment()`, `extract_from_environment()`, + LevelEditPanel UI |
| In-game edit panel | `scenes/states/playing/level_edit_panel.gd` (extends DrawerContainer) |
| Slide-out drawer | Extend `DrawerContainer`, configure edge/width/tab_text in `_on_ready()` |
| Shared constant | `autoloads/constants.gd` (registered as `Constants` autoload) |
| GLB utilities | `utils/glb_utils.gd` |
| Custom Resource | `resources/` with `class_name` |

## Key APIs

```gdscript
# Models (async, cached) — for tokens
var model = await AssetPackManager.get_model_instance(pack_id, asset_id, variant_id)

# Map loading (unified pipeline — handles res:// and user:// with full post-processing)
var map = await GlbUtils.load_map_async(path, true, light_scale)
# or synchronously:
var map = GlbUtils.load_map(path, true, light_scale)

# UI
UIManager.show_success("Done!")
UIManager.register_overlay(self)  # For ESC handling

# TabContainer — consistent cross-fade + tick sound on tab switch
tab_container.tab_changed.connect(_on_tab_changed)
func _on_tab_changed(_idx: int) -> void:
    TabUtils.animate_tab_change(tab_container, self)

# Environment (layered: PROPERTY_DEFAULTS → map_defaults → preset → overrides)
EnvironmentPresets.apply_to_world_environment(world_env, preset, overrides, map_sky, map_defaults)
var config = EnvironmentPresets.get_environment_config(preset, overrides, map_defaults)
var extracted = EnvironmentPresets.extract_from_environment(env)
```

## Formatting

After editing any file, run the formatter for that file type (see `formatting.mdc`). For GDScript: `gdformat path/to/file.gd`. Optional lint: `gdlint path/to/file.gd`.

## CanvasLayer & Input Safety

- **Layer numbers** are centralized in `Constants` (`LAYER_*`). Check existing screen regions before adding UI.
- **mouse_filter** – Set `MOUSE_FILTER_IGNORE` on layout-only containers. See `.cursor/rules/canvas-layers.mdc`.
- **Programmatic CanvasLayers** – Use `Constants.LAYER_DIALOG`, etc. instead of magic numbers.

## Do Not

- Create or use a global EventBus
- Edit `.uid` files manually
- Block main thread for I/O – use async/await or threaded loading
- Use `has_node("/root/X")` or `get_node("/root/X")` for autoloads – reference them directly
- Leave `_process()` running when idle – use `set_process(false)` and toggle as needed
- Use magic numbers for CanvasLayer layers – use `Constants.LAYER_*` in code, and keep `.tscn` values in sync with `constants.gd`
- Leave `mouse_filter = STOP` (default) on bare layout containers – always set `IGNORE` on non-interactive wrappers
- Bake map environment defaults into `level_data` – they are derived from the map file at load time
- Mutate `level_data` when applying environment settings – the effective config should be computed at apply-time via the layering model
